# Supervisor
Основной жизненный цикл симулятора представлен классом Superviser.
Цикл запускается после загрузки сценария и инициализации инфраструктуры.
Superviser на каждой итерации цикла вызывает `update(secondsElapsed)` у акторов.

# Actor
В симуляторе все участники сети u-transnet представлены классом `Actor` и его наследниками.
Актор может взаимодействовать с блокчейном через сервис [`ExternalAPI`](ExternalAPI.md)
и свою учетную запись БЧ: поле `UserAccount uTransnetAccount`.

### update(secondsElapsed)
Метод вызывается на каждой итерации жизненного цикла симулятора.
Основная работа актора выполняется в данном методе (вызываеются другие методы в нем),
при этом наследникам нет необходимости переопределять метод для добавления свой логики.
Однако, в случае переопределения, необходимо вызвать `super.update(seconds)`,
чтобы избежать нарушения работы актора.

На каждой итерации актор проверяет новые транзакции для своего аккаунта.
 
### Transaction Listener и Delayed Action
Для добавления логики работы конкретной реализации актора, пердусмотрено несколько механизмов.
#### Transaction Listener
С помощью метода `addOperationListener()` можно задать обработчик транзакции.
Обработчик задаются на конкретный тип транзакции и вызывается при получении новых транзакций.
#### Delayed Action
С помощью данного механизма можно задать действие, которое выполнится один раз по истечению
заданного времени.


# Actor Task
Механизм описания действия акторов с помощью последовательных задач.
У актора есть текущая задача и очередь ожидающих задач.
При этом задача может иметь следующую, таким образом получаеся цепочка задач.
В очередь помещается только первая задача цепочки, в дальнейшем цепочка переключается
автоматически.

На каждой итерации жизненного цикла, актор находится в ожидании выполнения текущей задачи.
По завершени текущей задачи есть два пути развития:
1. У выполненной задачи есть следующая.
Текущей задача актора будет автоматически выставлена следующая за выполненной.
2. У выполненной задачи нет следующий.
На следующей итерации, актор проверяет очередь задач и принимает следующую на исполнение.

Есть два типа условий выполнения задачи: по таймеру и по транзакции.
Во втором варианте можно задать условие успешного выполнения и отмены.

#### Этапы ActorTask
* `onStart` - выполняется, когда задача становится активной;
* `onEnd` - выполняется при успешном завершении задачи (по транзакции или таймеру);
* `onCancel` - выполняется при отмене (по транзакции или ошибке).

Когда ActorTask становится текущей задачей актора, он создает обработчики транзакций и 
добавляет действие по таймеру, если такие заданы при его создании.

При успешном выполнении задачи, актору автоматически будет назначена следубщая из данной цепочки.

При отмене, следующие задачи данной цепочки будут отброшены.

#### ActorTaskContext
Контекст задачи содержит условия выполнения задачи и дополнительные объекты.
Условия по транзакциям задаются с помощью функции двух аргументов
`BiFunction<ActorTaskContext, BaseOperation, Boolean>`:
функция принимает контекст и операцию заданного типа и возвращает `true`,
если выполнено заданное условие.

Контекст может содержать объекты, которые будут передавны во всемобработчики данной задачи:
`<T> T getPayload(String key)`, `ActorTaskContext addPayload(String key, Object value)`.
При переключении задач в цепочке, все объекты текущей задачи передаются в следующую, так может
быть реализован механиз передачи данных между задачами в одной цепочке.

#### Создание ActorTask
Для создания Actor необходимо использовать `ActorBuilder` полученный с помощью фабрики
`ActorFactory`. Для выполнения кода после создания объекта следует использовать метод
с аннотацией `@Postcunstruct`.
ActorTask создается с помощью `ActorTaskBuilder ActorTask.builder()`.
У каждой задачи должно быть имя, уникальное для данного актора.
Для упрозения создания цепочки задач, у Actor есть метод `ActorTaskBuilder createNext()`,
который автоматически свяжет задачи.

#### Пример создания
```java
import javax.annotation.PostConstruct;
public class SampleActor extends Actor {
    @PostConstruct
    private void init() {
        ActorTask buyRoputeMapTask = ActorTask.builder()
                .name("buy-route-map")
                .context(new ActorTaskContext(
                        OperationType.MESSAGE,
                        this::checkReceivedRouteMap
                ))
                .onStart(this::buyRouteMap)
                .build();
        buyRoputeMapTask.createNext()
    
                .name("buy-trip")
                .context(new ActorTaskContext(60))
                .onEnd(this::requestTrip)
                .build()
                .createNext()
    
                .name("wait-rail-car")
                .context(new ActorTaskContext(
                        OperationType.PROPOSAL_CREATE_OPERATION,
                        this::waitRailCar
                ))
                .onEnd(this::tellReadyForTrip)
                .build()
                .createNext()
    
                .name("start-trip")
                .context(new ActorTaskContext(60))
                .onEnd(this::tellInRailCar)
        ;
        addTask(buyRoputeMapTask);
    }
}
```
